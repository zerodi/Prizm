import { HttpEvent, HttpEventType, HttpClient } from '@angular/common/http';
import { Component, ChangeDetectionStrategy, OnDestroy } from '@angular/core';
import { PrizmFilesProgress, PrizmFileValidationErrors, PrizmToastService } from '@prizm-ui/components';

import { RawLoaderContent, TuiDocExample } from '@taiga-ui/addon-doc';
import { BehaviorSubject } from 'rxjs';

@Component({
  templateUrl: './file-upload-example.component.html',
  styleUrls: ['./file-upload-example.component.less'],
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class PrizmFileUploadExampleComponent implements OnDestroy {
  readonly basic: TuiDocExample = {
    TypeScript: import('./examples/basic/basic.component?raw'),
    HTML: import('./examples/basic/basic.component.html?raw'),
  };

  readonly autoUpload: TuiDocExample = {
    TypeScript: import('./examples/auto-upload/auto-upload.component?raw'),
    HTML: import('./examples/auto-upload/auto-upload.component.html?raw'),
  };

  readonly exampleI18n: TuiDocExample = {
    TypeScript: import('./examples/i18n/file-upload-i18n-example.component.ts?raw'),
    HTML: import('./examples/i18n/file-upload-i18n-example.component.html?raw'),
  };

  readonly exampleInForm: TuiDocExample = {
    TypeScript: import('./examples/file-upload-in-form/file-upload-in-form-example.component.ts?raw'),
    HTML: import('./examples/file-upload-in-form/file-upload-in-form-example.component.html?raw'),
  };

  readonly setupModule: RawLoaderContent = import('./examples/setup-module.md?raw');

  userContentRu = 'текст пользователя';
  userContentEng = 'user text';

  accept = 'image/*';
  acceptVariants: Array<string> = ['image/*', '.pdf', '.doc, .docx'];

  maxFileSize = 1e6;
  maxFilesCount = 3;
  public multiple = true;

  progress$$ = new BehaviorSubject<PrizmFilesProgress>({});
  files: Array<File> = [];
  disabled = false;

  constructor(private readonly toastService: PrizmToastService, private http: HttpClient) {}

  public onFilesChange(files: Array<File>): void {
    this.files = files;
  }

  public onfilesValidationErrors(errors: { [key: string]: PrizmFileValidationErrors }): void {
    for (const filename of Object.keys(errors)) {
      this.toastService.create(JSON.stringify(errors[filename]), {
        title: `Файл ${filename} не прошел валидацию`,
        appearance: 'warning',
        timer: 5000,
      });
    }
  }

  public onFilesCountError(fileNames: Array<string>): void {
    this.toastService.create(`Файлы ${fileNames.join(' ,')} не были добавлены`, {
      title: `Максимальное количество файлов превышено`,
      appearance: 'warning',
      timer: 5000,
    });
  }

  public send(): void {
    this.disabled = true;
    const formData = new FormData();
    for (const file of this.files) {
      formData.append(file.name, file);
    }

    this.http
      .post('/fakeFileUpload', formData, {
        reportProgress: true,
        observe: 'events',
      })
      .subscribe(
        (event: HttpEvent<any>) => {
          switch (event.type) {
            case HttpEventType.Sent:
              break;
            case HttpEventType.Response: {
              this.disabled = false;

              if (event.status >= 200 && event.status < 300) {
                for (const file of this.files) {
                  this.progress$$.next({
                    ...this.progress$$.value,
                    [file.name]: { progress: 100, error: false },
                  });
                }
              } else {
                for (const file of this.files) {
                  this.progress$$.next({
                    ...this.progress$$.value,
                    [file.name]: { error: true },
                  });
                }
              }

              break;
            }
            case HttpEventType.UploadProgress: {
              for (const file of this.files) {
                this.progress$$.next({
                  ...this.progress$$.value,
                  [file.name]: {
                    progress: Math.round((event.loaded / (event?.total ?? 0)) * 100),
                    error: false,
                  },
                });
              }

              break;
            }
          }
        },
        error => {
          console.log(error);
        }
      );
  }

  public retry(file: File): void {
    this.disabled = true;
    const formData = new FormData();

    formData.append(file.name, file);

    this.http
      .post('/fakeFileUpload', formData, {
        reportProgress: true,
        observe: 'events',
      })
      .subscribe(
        (event: HttpEvent<any>) => {
          switch (event.type) {
            case HttpEventType.Sent:
              break;
            case HttpEventType.Response: {
              this.disabled = false;

              if (event.status >= 200 && event.status < 300) {
                this.progress$$.next({
                  ...this.progress$$.value,
                  [file.name]: { progress: 100, error: false },
                });
              } else {
                this.progress$$.next({
                  ...this.progress$$.value,
                  [file.name]: { error: true },
                });
              }

              break;
            }
            case HttpEventType.UploadProgress: {
              this.progress$$.next({
                ...this.progress$$.value,
                [file.name]: {
                  progress: Math.round((event.loaded / (event.total ?? 0)) * 100),
                  error: false,
                },
              });

              break;
            }
          }
        },
        error => {
          console.log(error);
        }
      );
  }

  public ngOnDestroy(): void {
    this.progress$$.complete();
  }
}
